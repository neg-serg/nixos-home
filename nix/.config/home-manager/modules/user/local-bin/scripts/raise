#!/usr/bin/env bash
set -euo pipefail

# Simple Hyprland window raiser:
# - Focus existing window(s) by matcher or class, else launch.
# - Prefer native Hyprland matcher when provided via --match.
#
# Usage examples:
#   raise --class "term" --launch "kitty --class term"
#   raise --match "class:regex=^(firefox|floorp)$" --launch "$browser"

CLASS_REGEX=""
MATCH_EXPR=""
LAUNCH_CMD=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --match)
      MATCH_EXPR=${2:-}
      shift 2
      ;;
    --class)
      CLASS_REGEX=${2:-}
      shift 2
      ;;
    --launch)
      LAUNCH_CMD=${2:-}
      shift 2
      ;;
    --help|-h)
      echo "Usage: raise --class REGEX --launch COMMAND" >&2
      exit 0
      ;;
    *)
      echo "Unknown argument: $1" >&2
      exit 2
      ;;
  esac
done

if [[ -z "$MATCH_EXPR" && -z "$CLASS_REGEX" ]]; then
  echo "Usage: raise --match MATCHER | --class REGEX [--launch CMD]" >&2
  exit 2
fi

# Try to focus via Hyprland directly when possible
if command -v hyprctl >/dev/null 2>&1; then
  # 1) Explicit matcher has top priority, normalize known forms and pass through
  if [[ -n "$MATCH_EXPR" ]]; then
    # Hyprland expects :regex: not :regex=
    MATCH_NORM=${MATCH_EXPR//:regex=/:regex:}
    if hyprctl dispatch focuswindow "$MATCH_NORM" >/dev/null 2>&1; then
      exit 0
    fi
  fi

  # 2) Class regex via native dispatch
  if [[ -n "$CLASS_REGEX" ]]; then
    if hyprctl dispatch focuswindow "class:$CLASS_REGEX" >/dev/null 2>&1; then
      exit 0
    fi
  fi

  # 3) Fallback JSON scan by class regex if provided
  if [[ -n "$CLASS_REGEX" ]] && command -v jq >/dev/null 2>&1; then
    if ADDR=$(hyprctl clients -j | jq -r --arg re "$CLASS_REGEX" '.[] | select(.class|test($re)) | .address' | head -n1); then
      if [[ -n "$ADDR" ]]; then
        hyprctl dispatch focuswindow "address:$ADDR" >/dev/null 2>&1 && exit 0 || true
      fi
    fi
  fi
fi

# If focusing failed or Hyprland not present, launch the command if provided
if [[ -n "$LAUNCH_CMD" ]]; then
  exec bash -lc "$LAUNCH_CMD"
fi

exit 1
