diff --git a/bliss-audio-0.10.1/src/cue.rs b/bliss-audio-0.10.1/src/cue.rs
index 3508c7a..ef39d5d 100644
--- a/bliss-audio-0.10.1/src/cue.rs
+++ b/bliss-audio-0.10.1/src/cue.rs
@@
-use std::path::Path;
-use std::time::Duration;
-use std::{marker::PhantomData, path::PathBuf};
+use std::path::Path;
+use std::time::Duration;
+use std::{marker::PhantomData, path::PathBuf};
+use std::{ffi::OsStr, fs};
@@
-            let audio_file_path = match &self.cue_path.parent() {
-                Some(parent) => parent.join(Path::new(&cue_file.file)),
-                None => PathBuf::from(cue_file.file.to_owned()),
-            };
+            let audio_file_path = match resolve_audio_path(&self.cue_path, &cue_file.file) {
+                Some(path) => path,
+                None => {
+                    cue_files.push(Err(BlissError::DecodingError(format!(
+                        "audio file referenced in CUE sheet '{:?}' not found (entry: {:?})",
+                        self.cue_path, cue_file.file
+                    ))));
+                    continue;
+                }
+            };
@@
                cue_files.push(Err(raw_song.unwrap_err()));
            }
        }
        cue_files
    }
 }

+fn resolve_audio_path(cue_path: &Path, entry: &str) -> Option<PathBuf> {
+    let cue_dir = cue_path.parent()?;
+    let relative = Path::new(entry);
+    let file_name = relative.file_name().map(PathBuf::from);
+    let mut search_dirs = Vec::new();
+    search_dirs.push(cue_dir.to_path_buf());
+    if let Some(parent) = cue_dir.parent() {
+        search_dirs.push(parent.to_path_buf());
+        if let Some(grand) = parent.parent() {
+            search_dirs.push(grand.to_path_buf());
+        }
+    }
+
+    for dir in &search_dirs {
+        let candidate = dir.join(relative);
+        if candidate.exists() {
+            return Some(candidate);
+        }
+        if let Some(name) = &file_name {
+            let candidate = dir.join(name);
+            if candidate.exists() {
+                return Some(candidate);
+            }
+        }
+    }
+
+    if let Some(name) = &file_name {
+        let target_key = normalized_key(name.as_os_str());
+        for dir in &search_dirs {
+            if let Ok(entries) = fs::read_dir(dir) {
+                for entry in entries.flatten() {
+                    let path = entry.path();
+                    if path.is_file() {
+                        if let Some(candidate_name) = path.file_name() {
+                            if normalized_key(candidate_name) == target_key {
+                                return Some(path);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    None
+}
+
+fn normalized_key(name: &OsStr) -> String {
+    name
+        .to_string_lossy()
+        .chars()
+        .filter(|c| c.is_alphanumeric())
+        .flat_map(|c| c.to_lowercase())
+        .collect()
+}

